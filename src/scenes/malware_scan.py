from scene import Scene
from screen import Screen

from pathlib import Path
import time
import random


class MalwareScan(Scene):

    # Folders saved at a time
    MAXIMUM_FOLDERS_SAVED = 1000

    # The time of execution in seconds (currently "minimum" is redundant)
    MINIMUM_EXECUTION_TIME = 5 * 60

    # The random number generator's start/end
    RANDOM_SUSPICIOUS_FLAG_GENERATION_START = 1
    RANDOM_SUSPICIOUS_FLAG_GENERATION_END = 1000

    # When this number is generated the file is considered "suspicious"
    RANDOM_SUSPICIOUS_FLAG = 557

    def scanFolder(self, rootpath: Path):
        dirs = [rootpath.absolute()]
        while dirs:
            directory = dirs.pop(0)
            try:
                for item in directory.iterdir():
                    item = item.absolute()
                    if item.is_symlink():
                        continue
                    elif item.is_dir():
                        if len(dirs) < self.MAXIMUM_FOLDERS_SAVED:
                            dirs.append(item)
                    else:
                        yield item
            except PermissionError:
                pass

    def run(self, screen: Screen):
        start = time.time()
        for item in self.scanFolder(Path("/")):
            try:
                stats = item.stat()
                delta = stats.st_size / 1024 ** 2

                t = delta * 0.01
                if t < 0.01:
                    t = 0.01
                elif t > 5:
                    t = 5
                screen.log(f"Scanning {item}...")
                time.sleep(t)

                suspicious = random.randint(self.RANDOM_SUSPICIOUS_FLAG_GENERATION_START,
                                            self.RANDOM_SUSPICIOUS_FLAG_GENERATION_END) == self.RANDOM_SUSPICIOUS_FLAG
                if suspicious:
                    screen.error(item, "seems suspicious")
                else:
                    screen.success(item, "is safe")
            except (PermissionError, FileNotFoundError):
                pass
            if time.time() - start > self.MINIMUM_EXECUTION_TIME:
                break
